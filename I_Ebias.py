import multiprocessing
import os
from typing import Union
from zipfile import ZipFile

import matplotlib.pyplot as plt
import numpy as np
import scipy.signal
from scipy.constants import physical_constants

G0, *_ = physical_constants['conductance quantum']


def conductance(I: np.ndarray, V: np.ndarray, log: bool = True, **kwargs) -> np.ndarray:
    """
    Calculate conductance

    Args:
        I (ndarray): current (A)
        V (ndarray): E bias (V)
        log (bool, optional): return conductance in linear (G) or logscale log(G/G0)

    Returns:
        G (ndarray): conductance
    """
    if log:
        return np.log(np.abs(I / V) / G0)
    else:
        return np.abs(I / V / G0)


def __read_text(string, sep='\r\n'):
    A = np.fromstring(string, sep=sep)
    return A.reshape((A.size // 2, 2)).T


def load_data(path: Union[str, bytes], threads: int = multiprocessing.cpu_count(), **kwargs) -> tuple[np.ndarray, np.ndarray]:
    """
    Load txt files generated by LabView DAQ

    Args:
        path (str): directory of files, zip file, or txt file
        threads (int, optional): number of CPU threads to use, default use all

    Returns:
        I (ndarray): current (A) in 1D array
        V (ndarray): E bias (V) in 1D array
    """
    txt_filter = lambda file: file.endswith('.txt')
    if os.path.isdir(path):
        files = filter(txt_filter, os.listdir(path))
        files = [open(os.path.join(path, file), 'rb').read() for file in files]
        if files:
            with multiprocessing.Pool(threads) as pool:
                V, I = np.concatenate(pool.map(__read_text, files), axis=1)
                return I * 1e-6, V
        else:
            return np.array([]), np.array([])
    elif path.endswith('zip'):
        with multiprocessing.Pool(threads) as pool, ZipFile(path) as zf:
            files = filter(txt_filter, zf.namelist())
            files = map(zf.read, files)
            V, I = np.concatenate(pool.map(__read_text, files), axis=1)
            return I * 1e-6, V
    elif path.endswith('.txt'):
        I, V = np.loadtxt(path).T
        return I * 1e-6, V


def extracted_data(I: np.ndarray, V: np.ndarray, height: float = 1.4, length: int = 1200, **kwargs) -> tuple[np.ndarray, np.ndarray]:
    '''
    Extract segments from raw_data

    Args:
        I (ndarray): current (A) in 1D array
        V (ndarray): E bias (V) in 1D array
        height (float, optional): peak height of E bias
        length (int, optional): length of segments

    Returns:
        I (ndarray): current (A) in 2D array (#segments, length)
        V (ndarray): E bias (V) in 2D array (#segments, length)
    '''
    peaks, *_ = scipy.signal.find_peaks(abs(V), height=height)
    start, end = peaks[:-1].ravel(), peaks[1:].ravel()
    filter = (end - start) == length
    return np.stack([[I[i:j], V[i:j]] for i, j in zip(start[filter], end[filter])], axis=1)


def noise_remove(I, V, V_range=0.1, zeroing=False, **kwargs):
    '''
    Remove noise segments

    Args:
        I (ndarray): current (A) in 2D array (#segments, length)
        V (ndarray): E bias (V) in 2D array (#segments, length)
        V_range (float, optional): Remove segments that I.min() is not between Â±V_range
        zeroing (bool, optional): set I.min() at V=0

    Returns:
        I (ndarray): current (A) in 2D array (#segments, length)
        V (ndarray): E bias (V) in 2D array (#segments, length)
    '''
    zero_point = np.diagonal(V[:, np.abs(I).argmin(axis=1)])
    filter = np.abs(zero_point) < V_range
    I, V = I[filter], V[filter]
    if zeroing:
        V = V - np.expand_dims(zero_point[filter], axis=1)
    return I, V


def split_scan_direction(I: np.ndarray, V: np.ndarray, **kwargs) -> tuple[tuple[np.ndarray, np.ndarray], tuple[np.ndarray, np.ndarray]]:
    '''
    Split E bias scanning direction

    Args:
        I (ndarray): current (A) in 2D array (#segments, length)
        V (ndarray): E bias (V) in 2D array (#segments, length)

    Returns:
        ascending (tuple):  tuple of current and ascending E bias
        descending (tuple):  tuple of current and descending E bias
    '''
    filter = np.where((V[:, -1] - V[:, 0]) > 0, True, False)
    ascending = I[filter], V[filter]
    descending = I[~filter], V[~filter]
    return ascending, descending


class Hist2d:

    def __init__(self, I, V, **kwargs) -> None:
        self.I = I.ravel()
        self.V = V.ravel()

    def plot_GV(self, x_min: float = -1.5, x_max: float = 1.5, num_x_bin: float = 300, y_min: float = 1e-5, y_max: float = 1e-1, num_y_bin: float = 300):
        G = conductance(self.I, self.V, log=False)
        x_bins = np.linspace(x_min, x_max, num_x_bin + 1)
        y_bins = np.logspace(np.log10(y_min), np.log10(y_max), num_y_bin + 1)
        plt.hist2d(self.V, G, (x_bins, y_bins))
        plt.yscale('log')

    def plot_IV(self, x_min: float = -1.5, x_max: float = 1.5, num_x_bin: float = 300, y_min: float = 1e-10, y_max: float = 1e-5, num_y_bin: float = 300):
        x_bins = np.linspace(x_min, x_max, num_x_bin + 1)
        y_bins = np.logspace(np.log10(y_min), np.log10(y_max), num_y_bin + 1)
        plt.hist2d(self.V, np.abs(self.I), (x_bins, y_bins))
        plt.yscale('log')