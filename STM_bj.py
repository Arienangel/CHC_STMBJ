import atexit
import multiprocessing
import os
import time
from typing import Literal, Union
from zipfile import ZipFile

import matplotlib.pyplot as plt
import numpy as np
import scipy.interpolate
import scipy.optimize
import scipy.signal
import yaml
from watchdog.events import FileCreatedEvent, FileSystemEventHandler
from watchdog.observers import Observer


def gaussian(x, a, u, s):
    return a * np.exp(-((x - u) / s)**2 / 2)


def __read_text(string, sep='\r\n'):
    return np.fromstring(string, sep=sep)


def load_data(path: Union[str, bytes], threads: int = multiprocessing.cpu_count(), **kwargs) -> np.ndarray:
    """
    Load txt files generated by LabView DAQ

    Args:
        path (str): directory of files, zip file, or txt file
        threads (int, optional): number of CPU threads to use, default use all

    Returns:
        raw_data (ndarray): 1D array contains all of data

    """
    txt_filter = lambda file: file.endswith('.txt')
    if os.path.isdir(path):
        files = filter(txt_filter, os.listdir(path))
        files = [open(os.path.join(path, file), 'rb').read() for file in files]
        if files:
            with multiprocessing.Pool(threads) as pool:
                return np.concatenate(pool.map(__read_text, files))
        else:
            return np.array([])
    elif path.endswith('zip'):
        with multiprocessing.Pool(threads) as pool, ZipFile(path) as zf:
            files = filter(txt_filter, zf.namelist())
            files = map(zf.read, files)
            return np.concatenate(pool.map(__read_text, files))
    elif path.endswith('.txt'):
        return np.loadtxt(path)


def extract_data(raw_data: Union[np.ndarray, str], length: int = 1000, upper: float = 2, lower: float = 1e-4, method: Literal['pull', 'crash', 'both'] = 'pull', **kwargs) -> np.ndarray:
    '''
    Extract useful data from raw_data

    Args:
        raw_data (ndarray | str): 1D array contains raw data, directory of files, zip file, or txt file
        length (int, optional): length of extracted data per trace
        upper (float, optional): extract data greater than upper limit
        lower (float, optional): extract data less than lower limit
        method (str, optional): 'pull', 'crash' or 'both'

    Returns:
        extracted_data (ndarray): 2D array with shape (trace, length)
    '''
    if isinstance(raw_data, str): raw_data = load_data(raw_data, **kwargs)
    if raw_data.size:
        split = np.stack(np.split(raw_data, raw_data.size / length), axis=0)
        res = split[np.where((split.max(axis=1) > upper) & (split.min(axis=1) < lower), True, False)]
        if method == 'pull': res = res[np.where(res[:, 0] > res[:, -1], True, False)]
        elif method == 'crash': res = res[np.where(res[:, 0] < res[:, -1], True, False)]
        elif method == 'both': pass
        return res
    else:
        return np.empty((0, length))


class Hist1D:
    """
    1D histogram

    Args:
        min (float)
        max (float)
        num_bin (float)

    Attributes:
        trace (int): number of traces
        bins (ndarray): 1D array of bin edges, logarithmic scale
        height (ndarray): values of the histogram
        fig (Figure): plt.Figure object
        ax (Axes): plt.Axes object
        plot (StepPatch): plt 1D histogram container
    """

    def __init__(self, min: float = 1e-5, max: float = 10**0.5, num_bin: float = 1000, **kwargs) -> None:
        self.min, self.max = min, max
        self.bins = np.logspace(np.log10(min), np.log10(max), num_bin + 1)
        self.height, *_ = np.histogram([], self.bins)
        self.trace = 0
        self.fig, self.ax = plt.subplots()
        self.plot = self.ax.stairs(np.zeros(self.bins.size - 1), self.bins, fill=True)
        self.ax.set_xscale('log')
        self.ax.set_xlim(left=self.min, right=self.max)
        self.ax.set_xlabel('$Conductance\/(G/G_0)$')
        self.ax.set_ylabel('$Count/trace$')
        self.ax.grid(visible=True, which='major')

    @property
    def height_per_trace(self):
        """ndarray: histogram height devided by trace"""
        return self.height / self.trace

    def add_data(self, data: np.ndarray, **kwargs) -> None:
        """
        Add data into histogram

        Args:
            data (ndarray): 2D array with shape (trace, length)
        """
        self.trace = self.trace + data.shape[0]
        self.height = self.height + np.histogram(data, self.bins)[0]
        height_per_trace = self.height_per_trace
        self.plot.set_data(height_per_trace)
        self.ax.set_ylim(0, height_per_trace.max())
        '''peak, *_ = scipy.signal.find_peaks(height_per_trace, prominence=0.1)
        peak_position = self.bins[peak], height_per_trace[peak]
        self.ax.plot(*peak_position, 'xr')
        for i, j in zip(*peak_position):
            self.ax.annotate(f'{i:1.2E}', xy=(i, j+0.02), ha='center', fontsize=8)'''

    def get_peak(self, *, window_length=25, polyorder=5, prominence=0.05):
        """
        Get peak position and width by fitting Gaussian function

        Args:
            window_length (int)
            polyorder (int)
            prominence (float)

        Returns:
            avg (ndarray): average
            stdev (ndarray): standard derivative
            height (ndarray): peak height
        """
        x = np.sqrt(self.bins[:-1] * self.bins[1:])
        y = (self.height - self.height.min()) / (self.height.max() - self.height.min())
        y = scipy.signal.savgol_filter(y, window_length, polyorder)
        peak, *_ = scipy.signal.find_peaks(y, prominence=prominence)
        _, _, left, right = scipy.signal.peak_widths(y, peak, rel_height=1)
        left, right = np.ceil(left).astype(int), np.ceil(right).astype(int)
        avg, stdev, height = [], [], []
        for i in range(left.size):
            (a, u, s), *_ = scipy.optimize.curve_fit(gaussian, x[left[i]:right[i]], self.height[left[i]:right[i]], bounds=(0, np.inf))
            avg.append(u)
            stdev.append(s)
            height.append(a)
        return np.array(avg), np.array(stdev), np.array(height)


class Hist2D:
    """
    2D histogram

    Args:
        x_min (float)
        x_max (float)
        num_x_bin (float)
        y_min (float)
        y_max (float)
        num_y_bin (float)

    Attributes:
        trace (int): number of traces
        x_bins (ndarray): 1D array of bin edges, linear scale
        y_bins (ndarray): 1D array of bin edges, logarithmic scale
        height (ndarray): values of the histogram
        fig (Figure): plt.Figure object
        ax (Axes): plt.Axes object
        plot (QuadMesh): plt 2D histogram container

    """

    def __init__(self, x_min: float = -1, x_max: float = 1, num_x_bin: float = 100, y_min: float = 1e-5, y_max: float = 10**0.5, num_y_bin: float = 100, **kwargs) -> None:
        self.x_min, self.x_max, self.y_min, self.y_max = x_min, x_max, y_min, y_max
        self.x_bins = np.linspace(x_min, x_max, num_x_bin + 1)
        self.y_bins = np.logspace(np.log10(self.y_min), np.log10(self.y_max), num_y_bin + 1)
        self.height, *_ = np.histogram2d([], [], (self.x_bins, self.y_bins))
        self.trace = 0
        self.fig, self.ax = plt.subplots()
        self.plot = self.ax.pcolormesh(self.x_bins, self.y_bins, np.zeros((self.y_bins.size - 1, self.x_bins.size - 1)), cmap='viridis', vmin=0)
        self.ax.set_yscale('log')
        self.ax.set_xlim(left=self.x_min, right=self.x_max)
        self.ax.set_ylim(bottom=self.y_min, top=self.y_max)
        self.ax.set_xlabel('$Distance\/(nm)$')
        self.ax.set_ylabel('$Conductance\/(G/G_0)$')
        self.fig.colorbar(self.plot, ax=self.ax, shrink=0.5)

    @property
    def height_per_trace(self):
        """ndarray: histogram height devided by trace"""
        return self.height / self.trace

    def add_data(self, data: np.ndarray, x_conversion: float = 1, **kwargs) -> None:
        """
        Add data into histogram

        Args:
            data (ndarray): 2D array with shape (trace, length)
            x_conversion (float, optional): divide x axis by this value
        """
        self.trace = self.trace + data.shape[0]
        nearest = np.argpartition(np.abs(data - 0.5), 2, -1)[:, :2]
        x1, x2 = np.split(nearest, 2, axis=1)
        y1, y2 = np.split(np.take_along_axis(data, nearest, axis=-1), 2, axis=1)
        zero_point = x1 + (0.5 - y1) / (y2 - y1) * (x2 - x1)
        _, x = np.mgrid[:data.shape[0], :data.shape[-1]]
        x = (x - zero_point) / x_conversion
        self.height = self.height + np.histogram2d(x.ravel(), data.ravel(), (self.x_bins, self.y_bins))[0]
        height_per_trace = self.height_per_trace
        self.plot.set_array(height_per_trace.T)
        self.plot.set_clim(0, height_per_trace.max())


class Run(FileSystemEventHandler):
    """
    Load data and plot

    Args:
        path (str): directory of files, or txt file
        hist1d (bool): plot 1D histogram or not
        hist2d (bool): plot 2D histogram or not
        realtime (bool): plot in realtime or plot once only, path should be directory if True
        x_conversion (float, optional): divide x axis by this value

    Attributes:
        hist1d (Hist1D)
        hist2d (Hist2D)
    """

    def __init__(self, path: str, hist1d: bool = True, hist2d: bool = True, realtime: bool = False, x_conversion: float = 1, **kwargs) -> None:
        super().__init__()
        self.path = path
        self.hist1d = Hist1D(**conf['Hist1D']) if hist1d else None
        self.hist2d = Hist2D(**conf['Hist2D']) if hist2d else None
        self.x_conversion = x_conversion
        if os.path.isdir(path):
            if os.listdir(path):
                self.add_data(self.path)
            else:
                pass  # empty directory
        else:
            realtime = False
            self.add_data(self.path)
        try:
            plt.show(block=not realtime)
        except KeyboardInterrupt:
            exit()
        if realtime:
            atexit.register(plt.close)
            self.__watchdog()
            print(f'Monitoring directory: {self.path}')
            self.__keep_alive()

    def add_data(self, path: str, **kwargs) -> None:
        """
        Add data into histogram

        Args:
            path (str): directory of files, zip file, or txt file
        """
        extracted = extract_data(path, **conf['extract_data'])
        if self.hist1d: self.hist1d.add_data(extracted)
        if self.hist2d: self.hist2d.add_data(extracted, self.x_conversion)

    def on_created(self, event):
        if isinstance(event, FileCreatedEvent):
            if (event.src_path.endswith('.txt')):
                try:
                    print(f'File create detected: {event.src_path}')
                    if os.path.getsize(event.src_path) == 0:
                        time.sleep(0.5)
                    self.add_data(event.src_path)
                except Exception as E:
                    print(f'ERROR: {type(E).__name__}: {E.args}')

    def __watchdog(self):
        observer = Observer()
        observer.schedule(self, path=self.path, recursive=False)
        observer.start()
        atexit.register(observer.stop)

    @staticmethod
    def __keep_alive():
        try:
            while True:
                plt.pause(0.5)
        except KeyboardInterrupt:
            exit()


if __name__ == '__main__':
    if os.path.exists('config.yaml'):
        import argparse
        parser = argparse.ArgumentParser()
        parser.add_argument("-p", "--path")
        args = parser.parse_args()
        with open('config.yaml', mode='r', encoding='utf-8') as f:
            conf = yaml.load(f.read().replace('\\', '/'), yaml.SafeLoader)
        if args.path:
            conf['Run']['path'] = args.path
        Run(**conf['Run'])
    else:
        print('Generating config file')
        with open('config.yaml', mode='w', encoding='utf-8') as f:
            yaml.safe_dump({'Run': {'path': './test_data', 'realtime': False, 'hist1d': True, 'hist2d': True, 'x_conversion': 800}, 'extract_data': {'length': 1000, 'upper': 3.2, 'lower': 1e-6, 'method': 'pull'}, 'Hist1D': {'min': 1e-05, 'max': 3.16, 'num_bin': 550}, 'Hist2D': {'x_min': -0.3, 'x_max': 0.5, 'num_x_bin': 800, 'y_min': 1e-05, 'y_max': 3.16, 'num_y_bin': 550}}, f) # yapf: disable
        print(f'Edit the config file and try again: {os.path.join(os.getcwd(), "config.yaml")}')
        input()
        exit()
